%include {
	#include <cassert>
	#include <cstdlib>
	#include <cstring>

	#include "udmf.hpp"
}
%name UDMF_Parse
%token_prefix UDMF_
%token_type {char*}
%token_destructor { free($$); }

translation_unit ::= global_expr_list.
global_expr_list ::= global_expr_list global_expr.
global_expr_list ::= .
global_expr ::= block.
global_expr ::= assignment_expr.

block ::= identifier(A) LEFT_PAREN expr_list RIGHT_PAREN. {
	printf("Block %s =>\n", A);
}

%type expr_list {udmf::List*}
%destructor expr_list { delete $$; $$ = nullptr; }
expr_list(L) ::= . {
	L = new udmf::List();
}
expr_list(L) ::= expr_list assignment_expr(R). {
	L->insert(std::move(*R));
	R = nullptr;
}

%type assignment_expr {udmf::Assignment*}
%destructor assignment_expr { delete $$; $$ = nullptr; }
assignment_expr(L) ::= identifier(R1) EQUALS value(R2) SEMICOLON. {
	L = new udmf::Assignment(std::move(*R1), std::move(*R2));
	R1 = nullptr;
	R2 = nullptr;
}

%type identifier {udmf::Identifier*}
%destructor identifier { delete $$; $$ = nullptr; }
identifier(L) ::= IDENTIFIER(R). {
	L = new udmf::Identifier(R);
	free(R);
}

%type value {udmf::Value*}
value(L) ::= INTEGER(R). {
	L = new udmf::Value(atoi(R));
	free(R);
}
value(L) ::= FLOAT(R). {
	L = new udmf::Value(atof(R));
	free(R);
}
value(L) ::= QUOTED_STRING(R). {
	L = new udmf::Value(R);
	free(R);
}
value(L) ::= KEYWORD(R). {
	if (strcmp(R, "true") == 0) {
		L = new udmf::Value(true);
	} else {
		L = new udmf::Value(false);
	}
	free(R);
}

%parse_accept {
	printf("Parsing complete!\n");
}
%parse_failure {
	fprintf(stderr, "Parse failed.\n");
}
%stack_overflow {
	fprintf(stderr, "Parser stack overflow.\n");
}
